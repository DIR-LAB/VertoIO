# -*- coding: utf-8 -*-
"""scalable_tuning_heuristic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V704gcsJNNtIEV8zklWNsyH2PWz6y1LK
"""

import os
import re
import csv
import sys
import copy
import math
import time
import random
import datetime
import subprocess

stat_name_list = [
    'observation_no',

    'osc_rpc_configuration_current.mppr_value',
    'osc_rpc_configuration_current.mrif_value',
    'osc_rpc_configuration_current.mdm_value',
    
    'llite_stats_read_bytes.no_of_samples',
    'llite_stats_read_bytes.sample_min',
    'llite_stats_read_bytes.sample_max',
    'llite_stats_read_bytes.samples_sum',
    'llite_stats_write_bytes.no_of_samples',
    'llite_stats_write_bytes.sample_min',
    'llite_stats_write_bytes.sample_max',
    'llite_stats_write_bytes.samples_sum',

    'ost_read_rpc_bytes_data.no_of_samples',
    'ost_read_rpc_bytes_data.sample_min',
    'ost_read_rpc_bytes_data.sample_max',
    'ost_read_rpc_bytes_data.samples_sum',
    'ost_read_rpc_usec_data.no_of_samples',
    'ost_read_rpc_usec_data.sample_min',
    'ost_read_rpc_usec_data.sample_max',
    'ost_read_rpc_usec_data.samples_sum',

    'ost_write_rpc_bytes_data.no_of_samples',
    'ost_write_rpc_bytes_data.sample_min',
    'ost_write_rpc_bytes_data.sample_max',
    'ost_write_rpc_bytes_data.samples_sum',
    'ost_write_rpc_usec_data.no_of_samples',
    'ost_write_rpc_usec_data.sample_min',
    'ost_write_rpc_usec_data.sample_max',
    'ost_write_rpc_usec_data.samples_sum',

    'osc_req_waittime_data.no_of_samples',
    'osc_req_waittime_data.sample_min',
    'osc_req_waittime_data.sample_max',
    'osc_req_waittime_data.samples_sum',
    'osc_req_active_data.no_of_samples',
    'osc_req_active_data.sample_min',
    'osc_req_active_data.sample_max',
    'osc_req_active_data.samples_sum',

    'cur_dirty_bytes',
    'cur_grant_bytes',
    'cur_read_rif',
    'pending_read_pages',
    'cur_write_rif',
    'pending_write_pages'
]

feature_name_list = [
    'is_dist_centered',
    'avg_pages_per_write_rpc',
    'write_avg_xfer_speed',
    'write_max_xfer_speed',
    'used_pct_dirty_cache',
    'waittime_to_mrif_ratio',
    'avg_waittime',
    'write_rpc_generation_rate',
    'avg_write_rpc_latency_per_unit_data',
    'avg_write_rpc_waittime',
    'avg_rpcs_in_flight',
    'actual_record_duration'
]

stat_summary_list = [
    'which observation it is (start from 1)',
    
    'max_pages_per_rpc (mppr)',
    'max_rpcs_in_flight (mrif)',
    'max_dirty_mb (mdm)',

    'total count of llite layer read IOs',
    'minimum size of llite layer read IOs',
    'maximum size of llite layer read IOs',
    'total size of all llite layer read IOs',
    'total count of llite layer write IOs',
    'minimum size of llite layer write IOs',
    'maximum size of llite layer write IOs',
    'total size of all llite layer write IOs',
    
    'total count of OSC layer read RPCs',
    'minimum size of OSC layer read RPCs',
    'maximum size of OSC layer read RPCs',
    'total size of all OSC layer read RPCs',
    'total count of OSC layer read RPCs',
    'minimum time spent by OSC layer read RPCs',
    'maximum time spent by OSC layer read RPCs',
    'total time spent by all OSC layer read RPCs',
    
    'total count of OSC layer write RPCs',
    'minimum size of OSC layer write RPCs',
    'maximum size of OSC layer write RPCs',
    'total size of all OSC layer write RPCs',
    'total count of OSC layer write RPCs',
    'minimum time spent by OSC layer write RPCs',
    'maximum time spent by OSC layer write RPCs',
    'total time spent by all OSC layer write RPCs',
    
    'total count of completed RPCs whose waittime got recorded',
    'minimum waittime recorded among all completed RPCs',
    'maximum waittime recorded among all completed RPCs',
    'total amount of waittime recorded for all completed RPCs',
    'total count of issued RPCs',
    'minimum RPCs in the air observed among all issued RPCs',
    'maximum RPCs in the air observed among all issued RPCs',
    'total RPCs in the air observed for all issued RPCs',
    
    'current amount of dirty pages (in bytes) in dirty page cache',
    'current amount of space the client has reserved for the writeback cache with each OST',
    'current amount of read RPCs in air',
    'pending amount of read pages waiting to be cached',
    'current amount of write RPCs in air',
    'pending amount of write pages waiting to be cached',
]

feature_summary_list = [
    'is pages_per_rpc distribution centered: Centered(+1), Decentered(-1), Empty(0)',
    'average pages observed among issued write RPCs',
    'average transfer speed of write RPCs',
    'maximum transfer speed of write RPCs',
    'percentages of dirty page cache that is occupied',
    'ratio of avg_waittime to max_rpcs_in_flight',
    'average of waittime for all completed RPCs',
    'how fast data is being utilized to generate RPCs',
    'the average amount of latency observed during write RPC communication for a unit (in Page, size = 4kB) of data',
    'average of waittime for completed write RPCs',
    'average number of observed RPCs in flight',
    'actual snapshot record duration'
]

# default rpc parameters configuration
default_mppr_value = 1024
default_mrif_value = 8
default_mdm_value = 2000

# rpc parameters highest limit
# The mrif_highest_limit is set to 32 due to the fact that rpcs_in_flight stats
# report the rpcs in particular flight number from [0 ~ 31]
mppr_highest_limit = 1024
mrif_highest_limit = 256
mdm_highest_limit = 2000

# rpc parameters lowest limit
mppr_lowest_limit = 1
mrif_lowest_limit = 1
mdm_lowest_limit = 1

client_page_size_in_bytes = 4096
megabytes_to_bytes = 1024*1024

significance_thrshld = 0.005
decentered_thrshld = 0.03
overlapped_write_thrshld = 3
dirty_utilzn_pct_thrshld = 0.80
dgrdn_thr_on_sat = 0.03
snap_record_duration = 0.5

# Tunable parameters
mppr_str = 'max_pages_per_rpc'
mdm_str = 'max_dirty_mb'
mrif_str = 'max_rpcs_in_flight'

# Future parameters to tune
mram = 'max_read_ahead_mb'
mrapfm = 'max_read_ahead_per_file_mb'
mrawm = 'max_read_ahead_whole_mb'

# Far in the future
mcm = 'max_cached_mb'

# Each path is cmmented with what parameters we will consider and
# also includes what parameters may be useful in future.

# rpc_stats, max_pages_per_rpc, osc_cached_mb, osc_stats
osc_proc_path = '/proc/fs/lustre/osc/'

# contention_seconds, cur_dirty_bytes, max_dirty_mb,
# max_rpcs_in_flight
osc_sys_fs_path = '/sys/fs/lustre/osc/'

# stats
osc_sys_kernel_path = '/sys/kernel/debug/lustre/osc/'

# max_cached_mb, max_read_ahead_mb, max_read_ahead_per_file_mb,
# max_read_ahead_whole_mb, read_ahead_stats, stats
llite_sys_kernel_path = '/sys/kernel/debug/lustre/llite/'

# Help us fetch the names
osc_list_of_names_fetch_cmd = ['lctl', 'list_param', 'osc.*']
llite_fs_fetch_cmd = ['lctl', 'list_param', 'llite.*']

# changing params
obsvn_cnt = -1
is_dflt = 0
is_dflt_txt = "tuned"

class Stat_Data:
    def __init__(self, module_name, no_of_samples = 0, sample_min = 0, sample_max = 0, samples_sum = 0):
        self.module_name = module_name
        self.no_of_samples = no_of_samples
        self.sample_min = sample_min
        self.sample_max = sample_max
        self.samples_sum = samples_sum

    def save_data(self, no_of_samples, sample_min, sample_max, samples_sum):
        self.no_of_samples = no_of_samples
        self.sample_min = sample_min
        self.sample_max = sample_max
        self.samples_sum = samples_sum

    def is_empty(self):
        if self.no_of_samples == 0:
            return True
        return False

    def get_average(self):
        if self.no_of_samples == 0:
            return 0
        return (self.samples_sum / self.no_of_samples)

    def show_data(self):
        print('no_of_samples: ', self.no_of_samples)
        print('sample_min: ', self.sample_min)
        print('sample_max: ', self.sample_max)
        print('samples_sum: ', self.samples_sum)

    def construct_params_list(self):
        params_list = []
        params_list = params_list + [self.no_of_samples]
        params_list = params_list + [self.sample_min]
        params_list = params_list + [self.sample_max]
        params_list = params_list + [self.samples_sum]

        return params_list

class OSC_Configuration:
    def __init__(self, osc_name, mppr_value = default_mppr_value, mrif_value = default_mrif_value, mdm_value = default_mdm_value):
        self.osc_name = osc_name
        
        self.mppr_value = default_mppr_value
        self.mrif_value = default_mrif_value
        self.mdm_value = default_mdm_value
        
    def __eq__(self, other): 
        if not isinstance(other, OSC_Configuration):
            # don't attempt to compare against unrelated types
            return NotImplemented

        return self.mppr_value == other.mppr_value and self.mrif_value == other.mrif_value and self.mdm_value == other.mdm_value
    
    def save_configuration_instance(self, other):
        self.mppr_value = other.mppr_value
        self.mrif_value = other.mrif_value
        self.mdm_value = other.mdm_value
    
    def save_configuration(self, mppr_value, mrif_value, mdm_value):
        self.mppr_value = mppr_value
        self.mrif_value = mrif_value
        self.mdm_value = mdm_value

    def show_configuration(self):
        print('mppr_value: ', self.mppr_value)
        print('mrif_value: ', self.mrif_value)
        print('mdm_value: ', self.mdm_value)

    def construct_params_list(self):
        params_list = []
        params_list = params_list + [self.mppr_value]
        params_list = params_list + [self.mrif_value]
        params_list = params_list + [self.mdm_value]

        return params_list

class OSC_Snapshot:
    def __init__(self, osc_name):
        self.osc_name = osc_name
        self.cur_dirty_bytes = 0
        self.cur_grant_bytes = 0
        self.pending_read_pages = 0
        self.pending_write_pages = 0

        self.cur_read_rif = 0
        self.cur_write_rif = 0
        
        self.read_ppr_dist = dict()
        self.write_ppr_dist = dict()

        self.read_rif_dist = dict()
        self.write_rif_dist = dict()

        self.ost_read_rpc_bytes_data = Stat_Data(osc_sys_kernel_path + osc_name)
        self.ost_write_rpc_bytes_data = Stat_Data(osc_sys_kernel_path + osc_name)

        self.ost_read_rpc_usec_data = Stat_Data(osc_sys_kernel_path + osc_name)
        self.ost_write_rpc_usec_data = Stat_Data(osc_sys_kernel_path + osc_name)

        self.osc_rpc_configuration_current = OSC_Configuration(osc_name)

        self.write_RPC_gnrn_rate = 0
        self.write_avg_xfer_speed = 0
        self.avg_write_rpc_latency_per_unit_data = 0

        self.osc_req_waittime_data = Stat_Data(osc_sys_kernel_path + osc_name)
        self.osc_req_active_data = Stat_Data(osc_sys_kernel_path + osc_name)

        self.waittime_to_mrif_ratio = 0
        self.llite_write_bytes = 0
        self.is_dist_centered = 0

    def save_cur_rif(self, cur_read_rif, cur_write_rif):
        self.cur_read_rif = cur_read_rif
        self.cur_write_rif = cur_write_rif

    def save_pending_pages(self, pending_read_pages, pending_write_pages):
        self.pending_read_pages = pending_read_pages
        self.pending_write_pages = pending_write_pages

    def save_ppr_dist(self, read_ppr_dist, write_ppr_dist):
        self.read_ppr_dist = read_ppr_dist
        self.write_ppr_dist = write_ppr_dist

    def save_rif_dist(self, read_rif_dist, write_rif_dist):
        self.read_rif_dist = read_rif_dist
        self.write_rif_dist = write_rif_dist

    def save_write_params(self, write_RPC_gnrn_rate, write_avg_xfer_speed, avg_write_rpc_latency_per_unit_data):
        self.write_RPC_gnrn_rate = write_RPC_gnrn_rate
        self.write_avg_xfer_speed = write_avg_xfer_speed
        self.avg_write_rpc_latency_per_unit_data = avg_write_rpc_latency_per_unit_data
    
    def show_dict(self, dict_element):
        for key in dict_element:
            print(key, ': ', dict_element[key])

    def show_snapshot(self):
        print('osc_name: ', self.osc_name)
        print('cur_dirty_bytes: ', self.cur_dirty_bytes)
        print('cur_grant_bytes: ', self.cur_grant_bytes)
        print('cur_read_rif: ', self.cur_read_rif)
        print('cur_write_rif: ', self.cur_write_rif)
        print('pending_read_pages: ', self.pending_read_pages)
        print('pending_write_pages: ', self.pending_write_pages)
        
        print('read_ppr_dist: ')
        self.show_dict(self.read_ppr_dist)
        print('write_ppr_dist: ')
        self.show_dict(self.write_ppr_dist)

        print('read_rif_dist: ')
        self.show_dict(self.read_rif_dist)
        print('write_rif_dist: ')
        self.show_dict(self.write_rif_dist)

        print('ost_read_rpc_bytes_data: ')
        self.ost_read_rpc_bytes_data.show_data()
        print('ost_write_rpc_bytes_data: ')
        self.ost_write_rpc_bytes_data.show_data()

        print('ost_read_rpc_usec_data: ')
        self.ost_read_rpc_usec_data.show_data()
        print('ost_write_rpc_usec_data: ')
        self.ost_write_rpc_usec_data.show_data()

        print('osc_rpc_configuration_current: ')
        self.osc_rpc_configuration_current.show_configuration()

        print('write_RPC_gnrn_rate: ', self.write_RPC_gnrn_rate, ' B/sec')
        print('write_avg_xfer_speed: ', self.write_avg_xfer_speed, ' B/sec')
        print('avg_write_rpc_latency_per_unit_data: ', self.avg_write_rpc_latency_per_unit_data, ' usec')

        print('osc_req_waittime_data: ')
        self.osc_req_waittime_data.show_data()
        print('osc_req_active_data: ')
        self.osc_req_active_data.show_data()

        print('waittime_to_mrif_ratio: ', self.waittime_to_mrif_ratio)
        print('llite_write_bytes: ', self.llite_write_bytes, ' Bytes')
        print('is_dist_centered: ', self.is_dist_centered)

    def construct_stats_list(self):
        params_list = []
        params_list = params_list + self.ost_read_rpc_bytes_data.construct_params_list()
        params_list = params_list + self.ost_read_rpc_usec_data.construct_params_list()

        params_list = params_list + self.ost_write_rpc_bytes_data.construct_params_list()
        params_list = params_list + self.ost_write_rpc_usec_data.construct_params_list()

        params_list = params_list + self.osc_req_waittime_data.construct_params_list()
        params_list = params_list + self.osc_req_active_data.construct_params_list()

        params_list = params_list + [self.cur_dirty_bytes]
        params_list = params_list + [self.cur_grant_bytes]
        params_list = params_list + [self.cur_read_rif]
        params_list = params_list + [self.pending_read_pages]
        params_list = params_list + [self.cur_write_rif]
        params_list = params_list + [self.pending_write_pages]

        return params_list

    def construct_features_list(self):
        params_list = []
        params_list = params_list + [self.is_dist_centered]
        params_list = params_list + [str(self.ost_write_rpc_bytes_data.get_average() / client_page_size_in_bytes)]
        params_list = params_list + [self.write_avg_xfer_speed]
        params_list = params_list + [str((self.osc_rpc_configuration_current.mrif_value * self.write_avg_xfer_speed))]
        params_list = params_list + [str(((self.cur_dirty_bytes / megabytes_to_bytes) / self.osc_rpc_configuration_current.mdm_value) * 100)]
        params_list = params_list + [self.waittime_to_mrif_ratio]
        params_list = params_list + [str(self.osc_req_waittime_data.get_average())]
        params_list = params_list + [self.write_RPC_gnrn_rate]
        params_list = params_list + [self.avg_write_rpc_latency_per_unit_data]
        params_list = params_list + [str(self.ost_write_rpc_usec_data.get_average())]
        params_list = params_list + [str(self.osc_req_active_data.get_average())]

        return params_list

class LLITE_Snapshot:
    def __init__(self):
        self.llite_fs_name = subprocess.run(llite_fs_fetch_cmd, stdout=subprocess.PIPE).stdout.decode('utf-8').splitlines()[0].split('.')[1]
        self.llite_stats_read_bytes = Stat_Data(llite_sys_kernel_path + self.llite_fs_name)
        self.llite_stats_write_bytes = Stat_Data(llite_sys_kernel_path + self.llite_fs_name)

    def show_snapshot(self):
        print('llite_fs_name: ', self.llite_fs_name)
        print('llite_stats_read_bytes: ')
        self.llite_stats_read_bytes.show_data()
        print('llite_stats_write_bytes: ')
        self.llite_stats_write_bytes.show_data()

    def construct_params_list(self):
        params_list = []
        params_list = params_list + self.llite_stats_read_bytes.construct_params_list()
        params_list = params_list + self.llite_stats_write_bytes.construct_params_list()
        
        return params_list

class Client_Snapshot:
    def __init__(self):
        self.osc_names = subprocess.run(osc_list_of_names_fetch_cmd, stdout=subprocess.PIPE).stdout.decode('utf-8').splitlines()
        for i in range(len(self.osc_names)):
            # osc.hasanfs-OST0000-osc-ffff977ebb01e000 ==> hasanfs-OST0000-osc-ffff977ebb01e000
            self.osc_names[i] = self.osc_names[i].split('.')[1]

        self.llite_snapshot = LLITE_Snapshot()

        self.osc_snapshots = dict()
        for osc_name in self.osc_names:
            self.osc_snapshots[osc_name] = OSC_Snapshot(osc_name)

        self.osc_header_added = dict()
        for osc_name in self.osc_names:
            self.osc_header_added[osc_name] = False

    def show_snapshot(self):
        self.llite_snapshot.show_snapshot()

        for osc_name in self.osc_names:
            self.osc_snapshots[osc_name].show_snapshot()

    def extract_dicts_from_stat_distribution(self, line_list, stat_matchmaker):
        read_dist = dict()
        write_dist = dict()
        
        for i in range(len(line_list)):
            try:
                line = line_list[i]
                stat_anchor = re.search('^' + stat_matchmaker + '(\s)*rpcs(\s)*% cum % \|(\s)*rpcs(\s)*% cum %$', line, re.IGNORECASE)
                if stat_anchor == None:
                    continue
                
                for j in range(i+1, len(line_list)):
                    try:
                        line_match = line_list[j]
                        dist_row_match = re.match('^(\d+):(\s)*(\d+)(\s)*(\d+)(\s)*(\d+)(\s)*\|(\s)*(\d+)(\s)*(\d+)(\s)*(\d+)$', line_match, re.IGNORECASE)
                        if dist_row_match == None:
                            return read_dist, write_dist
                        
                        read_dist[int(dist_row_match.group(1))] = (int(dist_row_match.group(3)), int(dist_row_match.group(5)), int(dist_row_match.group(7)))
                        write_dist[int(dist_row_match.group(1))] = (int(dist_row_match.group(10)), int(dist_row_match.group(12)), int(dist_row_match.group(14)))
                    
                    except AttributeError:
                        return read_dist, write_dist
            
            except AttributeError:
                stat_anchor = re.search('^' + stat_matchmaker + '(\s)*rpcs(\s)*% cum % \|(\s)*rpcs(\s)*% cum %$', line, re.IGNORECASE)
        
        return read_dist, write_dist

    def extract_stat_data_from_stats(self, line_list, attr_matchmaker):
        for line in line_list:
            try:
                attr_match = re.search('^' + attr_matchmaker + '(\s+)(\d+)(\s+)(\w+)(\s+)\[(\w+)\](\s+)(\d+)(\s+)(\d+)(\s+)(\d+)', line, re.IGNORECASE)
                no_of_samples = int(float(attr_match.group(2)))
                sample_min = int(float(attr_match.group(8)))
                sample_max = int(float(attr_match.group(10)))
                samples_sum = int(float(attr_match.group(12)))
                return no_of_samples, sample_min, sample_max, samples_sum
            
            except AttributeError:
                attr_match = re.search('^' + attr_matchmaker + '(\s+)(\d+)(\s+)(\w+)(\s+)\[(\w+)\](\s+)(\d+)(\s+)(\d+)(\s+)(\d+)', line, re.IGNORECASE)
        
        return 0, 0, 0, 0

    def extract_single_stat_data_from_stats(self, line_list, attr_matchmaker):
        for line in line_list:
            try:
                attr_match = re.search('^' + attr_matchmaker + ':(\s)+(\d)+', line, re.IGNORECASE)
                value_attr = int(float(attr_match.group(2)))
                return value_attr
            
            except AttributeError:
                attr_match = re.search('^' + attr_matchmaker + ':(\s)+(\d)+', line, re.IGNORECASE)
        
        return 0

    def save_osc_rpc_dist_stats_data(self, osc_name):
        rpc_stats_lines = []
        with open(osc_proc_path + osc_name + '/rpc_stats') as f:
            rpc_stats_lines = f.readlines()
        print(rpc_stats_lines)

        cur_read_rif = self.extract_single_stat_data_from_stats(rpc_stats_lines, 'read RPCs in flight')
        cur_write_rif = self.extract_single_stat_data_from_stats(rpc_stats_lines, 'write RPCs in flight')
        self.osc_snapshots[osc_name].save_cur_rif(cur_read_rif, cur_write_rif)

        pending_read_pages = self.extract_single_stat_data_from_stats(rpc_stats_lines, 'pending read pages')
        pending_write_pages = self.extract_single_stat_data_from_stats(rpc_stats_lines, 'pending write pages')
        self.osc_snapshots[osc_name].save_pending_pages(pending_read_pages, pending_write_pages)

        read_dist, write_dist = self.extract_dicts_from_stat_distribution(rpc_stats_lines, 'pages per rpc')
        self.osc_snapshots[osc_name].save_ppr_dist(read_dist, write_dist)

        read_dist, write_dist = self.extract_dicts_from_stat_distribution(rpc_stats_lines, 'rpcs in flight')
        self.osc_snapshots[osc_name].save_rif_dist(read_dist, write_dist)

    def save_osc_stats_data(self, osc_name):
        stats_lines = []
        with open(osc_sys_kernel_path + osc_name + '/stats') as f:
            stats_lines = f.readlines()
        print(stats_lines)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'req_waittime')
        self.osc_snapshots[osc_name].osc_req_waittime_data.save_data(no_of_samples, sample_min, sample_max, samples_sum)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'req_active')
        self.osc_snapshots[osc_name].osc_req_active_data.save_data(no_of_samples, sample_min, sample_max, samples_sum)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'read_bytes')
        self.osc_snapshots[osc_name].ost_read_rpc_bytes_data.save_data(no_of_samples, sample_min, sample_max, samples_sum)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'write_bytes')
        self.osc_snapshots[osc_name].ost_write_rpc_bytes_data.save_data(no_of_samples, sample_min, sample_max, samples_sum)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'ost_read')
        self.osc_snapshots[osc_name].ost_read_rpc_usec_data.save_data(no_of_samples, sample_min, sample_max, samples_sum)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'ost_write')
        self.osc_snapshots[osc_name].ost_write_rpc_usec_data.save_data(no_of_samples, sample_min, sample_max, samples_sum)

    def save_osc_rpc_params_data(self, osc_name):
        mppr_value = 0
        with open(osc_proc_path + osc_name + '/' + mppr_str) as f:
            mppr_value = int(f.read())

        mrif_value = 0
        with open(osc_sys_fs_path + osc_name + '/' + mrif_str) as f:
            mrif_value = int(f.read())

        mdm_value = 0
        with open(osc_sys_fs_path + osc_name + '/' + mdm_str) as f:
            mdm_value = int(f.read())

        self.osc_snapshots[osc_name].osc_rpc_configuration_current.save_configuration(mppr_value, mrif_value, mdm_value)

    def save_osc_params_data(self, osc_name):
        cur_dirty_bytes = 0
        with open(osc_sys_fs_path + osc_name + '/' + 'cur_dirty_bytes') as f:
            cur_dirty_bytes = int(f.read())

        self.osc_snapshots[osc_name].cur_dirty_bytes = cur_dirty_bytes

        cur_grant_bytes = 0
        with open(osc_proc_path + osc_name + '/' + 'cur_grant_bytes') as f:
            cur_grant_bytes = int(f.read())
        self.osc_snapshots[osc_name].cur_grant_bytes = cur_grant_bytes

    def save_llite_io_stats_data(self):
        stats_lines = []
        with open(llite_sys_kernel_path + self.llite_snapshot.llite_fs_name + '/stats') as f:
            stats_lines = f.readlines()
        print(stats_lines)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'read_bytes')
        self.llite_snapshot.llite_stats_read_bytes.save_data(no_of_samples, sample_min, sample_max, samples_sum)

        no_of_samples, sample_min, sample_max, samples_sum = self.extract_stat_data_from_stats(stats_lines, 'write_bytes')
        self.llite_snapshot.llite_stats_write_bytes.save_data(no_of_samples, sample_min, sample_max, samples_sum)
    
    def populate_snapshot(self):
        print('obsvn_cnt: ', obsvn_cnt+1)

        # Possible improvement by implementing threading here
        for osc_name in self.osc_names:
            self.save_osc_stats_data(osc_name)
            self.save_osc_rpc_dist_stats_data(osc_name)
            self.save_osc_rpc_params_data(osc_name)
            self.save_osc_params_data(osc_name)

        self.save_llite_io_stats_data()
        self.show_snapshot()

    def construct_stats_and_features_list_per_osc(self, llite_params_list, osc_snap, record_dur):
        global obsvn_cnt
        params_list = []
        params_list = params_list + [obsvn_cnt]

        params_list = params_list + osc_snap.osc_rpc_configuration_current.construct_params_list()

        params_list = params_list + llite_params_list

        params_list = params_list + osc_snap.construct_stats_list()
        params_list = params_list + osc_snap.construct_features_list()

        params_list = params_list + [record_dur]

        return params_list
    
    def write_stats_and_features_list_to_csv(self, result_folder_path, wld_name, osc_name, params_list):
        script_dir = os.path.abspath(os.path.dirname(__file__))
        '''
        # This transform the input of result_folder_path like following:
        #   dirname(script_dir/rpc_tuning_tests/"$wd_dir")
        #        = script_dir/rpc_tuning_tests
        dirname = os.path.dirname(os.path.join(script_dir, result_folder_path))
        osc_csv_filename = os.path.join(dirname, 'all_wld_csvs_with_system_stats_and_features', wld_name + "_" + osc_name + "_sheet_" + is_dflt_txt + ".csv")
        '''
        osc_csv_filename = os.path.join(script_dir, result_folder_path, wld_name + "_" + osc_name + "_sheet_" + is_dflt_txt + ".csv")

        with open(osc_csv_filename, "a") as csv_file:  
            writer = csv.writer(csv_file)
            writer.writerow([param for param in params_list])

    def include_stats_and_features_header_and_summary(self, result_folder_path, wld_name, osc_name):
        self.write_stats_and_features_list_to_csv(result_folder_path, wld_name, osc_name, stat_name_list + feature_name_list)
        self.write_stats_and_features_list_to_csv(result_folder_path, wld_name, osc_name, stat_summary_list + feature_summary_list)
    
    def store_params_to_csv(self, result_folder_path, wld_name, record_dur):
        global obsvn_cnt
        obsvn_cnt = obsvn_cnt + 1
        
        llite_params_list = self.llite_snapshot.construct_params_list()

        for osc_name in self.osc_names:
            # only stats and derived features
            if self.osc_header_added[osc_name] == False:
                self.include_stats_and_features_header_and_summary(result_folder_path, wld_name, osc_name)
                self.osc_header_added[osc_name] = True

            # only stats and derived features
            osc_stats_features_list = self.construct_stats_and_features_list_per_osc(llite_params_list, self.osc_snapshots[osc_name], record_dur)
            self.write_stats_and_features_list_to_csv(result_folder_path, wld_name, osc_name, osc_stats_features_list)

def do_increase_value(do_increase, cur_value, highest_limit, lowest_limit, param_path, param_str):
    if do_increase == True:
        # increase by a factor of 2
        new_value = min(cur_value * 2, highest_limit)
        subprocess.call('echo ' + str(new_value) + ' > ' + param_path + '/' + param_str, shell=True)
        print(param_str, " Previous Value: ", cur_value, " ====> New Value: ", new_value)
    else:
        # decrease by a factor of 2
        new_value = max(int(cur_value / 2), lowest_limit)
        subprocess.call('echo ' + str(new_value) + ' > ' + param_path + '/' + param_str, shell=True)
        print(param_str, " Previous Value: ", cur_value, " ====> New Value: ", new_value)

def do_increase_mppr(osc_snap, do_increase):
    cur_value = int(subprocess.run(['cat', osc_proc_path + osc_snap.osc_name + '/' + mppr_str], stdout=subprocess.PIPE).stdout.decode('utf-8'))
    do_increase_value(do_increase, cur_value, mppr_highest_limit, mppr_lowest_limit, (osc_proc_path + osc_snap.osc_name), mppr_str)

def do_increase_mrif(osc_snap, do_increase):
    cur_value = int(subprocess.run(['cat', osc_sys_fs_path + osc_snap.osc_name + '/' + mrif_str], stdout=subprocess.PIPE).stdout.decode('utf-8'))
    do_increase_value(do_increase, cur_value, mrif_highest_limit, mrif_lowest_limit, (osc_sys_fs_path + osc_snap.osc_name), mrif_str)

def do_increase_mdm(osc_snap, do_increase):
    cur_value = int(subprocess.run(['cat', osc_sys_fs_path + osc_snap.osc_name + '/' + mdm_str], stdout=subprocess.PIPE).stdout.decode('utf-8'))
    do_increase_value(do_increase, cur_value, mdm_highest_limit, mdm_lowest_limit, (osc_sys_fs_path + osc_snap.osc_name), mdm_str)

def set_mppr_value(osc_snap, param_value):
    param_value = param_value if param_value >= mppr_lowest_limit else mppr_lowest_limit
    param_value = param_value if param_value <= mppr_highest_limit else mppr_highest_limit

    subprocess.call('echo ' + str(param_value) + ' > ' + osc_proc_path + osc_snap.osc_name + '/' + mppr_str, shell=True)
    print("Previous Value: ", osc_snap.osc_rpc_configuration_current.mppr_value, " ====> New Value: ", param_value)

def set_mrif_value(osc_snap, param_value):
    param_value = param_value if param_value >= mrif_lowest_limit else mrif_lowest_limit
    param_value = param_value if param_value <= mrif_highest_limit else mrif_highest_limit

    subprocess.call('echo ' + str(param_value) + ' > ' + osc_sys_fs_path + osc_snap.osc_name + '/' + mrif_str, shell=True)
    print("Previous Value: ", osc_snap.osc_rpc_configuration_current.mrif_value, " ====> New Value: ", param_value)

def is_empty_dist(osc_dist):
    # Even the empty dist should have at least one rows.
    if len(osc_dist) == 1:
        for key in osc_dist:
            if osc_dist[key][0] == 0:
                return True
    
    for key in osc_dist:
        if osc_dist[key][0] != 0:
            return False
    return True

def is_dist_centered_around_param(osc_dist, param_value, param_majority_percentage):
    # dist is a dict of tuples: (rpc_count, % of total rpc_count, cumulative %)
    # the key of the dict is param value factored by 2

    for key in osc_dist:
        if key == param_value:
            if osc_dist[key][2] - osc_dist[key][1] > param_majority_percentage:
                return False
            return True

def is_distribution_centered(cur_osc_snap):
    avg_pages_per_rpc = cur_osc_snap.ost_write_rpc_bytes_data.get_average() / client_page_size_in_bytes
    cur_osc_mppr_value = cur_osc_snap.osc_rpc_configuration_current.mppr_value

    if avg_pages_per_rpc == 0 or is_empty_dist(cur_osc_snap.write_ppr_dist) == True:
        return True

    if avg_pages_per_rpc >= ((100-decentered_thrshld)/100)*cur_osc_mppr_value and is_dist_centered_around_param(cur_osc_snap.write_ppr_dist, cur_osc_mppr_value, decentered_thrshld) == True:
        return True
    
    return False

def get_write_RPC_gnrn_rate(cur_osc_snap, prev_osc_snap, record_dur):
    # The combination for current is [Pending IO Data + RPCs In Flight Data + Transferred Data]
    cur_avg_write_bytes_in_rpc = cur_osc_snap.ost_write_rpc_bytes_data.get_average()
    cur_total_gnrntd_data = (cur_osc_snap.cur_write_rif * cur_avg_write_bytes_in_rpc) + cur_osc_snap.ost_write_rpc_bytes_data.samples_sum

    prev_rif_data = prev_osc_snap.cur_write_rif * prev_osc_snap.ost_write_rpc_bytes_data.get_average()
    
    cur_actual_gnrntd_data  = cur_total_gnrntd_data - prev_rif_data
    write_RPC_gnrn_rate = int(cur_actual_gnrntd_data / record_dur)
    
    return write_RPC_gnrn_rate

def get_write_avg_xfer_speed(cur_osc_snap):
    if cur_osc_snap.ost_write_rpc_usec_data.samples_sum == 0:
        write_avg_xfer_speed = 0
    else:
        write_avg_xfer_speed = int((cur_osc_snap.ost_write_rpc_bytes_data.samples_sum / cur_osc_snap.ost_write_rpc_usec_data.samples_sum) * 1000000)
    
    return write_avg_xfer_speed

def get_avg_write_rpc_latency_per_unit_data(cur_osc_snap):
    avg_pages_per_write_rpc = cur_osc_snap.ost_write_rpc_bytes_data.get_average() / client_page_size_in_bytes
    avg_rpcs_in_flight = cur_osc_snap.osc_req_active_data.get_average()
    if avg_pages_per_write_rpc == 0 or avg_rpcs_in_flight == 0:
        return 0
    
    avg_write_rpc_waittime = cur_osc_snap.ost_write_rpc_usec_data.get_average()
    avg_write_rpc_latency_per_unit_data = (avg_write_rpc_waittime / (avg_pages_per_write_rpc * avg_rpcs_in_flight))

    return avg_write_rpc_latency_per_unit_data

def save_features(cur_snap, prev_snap, record_dur):
    llite_snap = cur_snap.llite_snapshot

    for osc_name in cur_snap.osc_names:
        cur_osc_snap = cur_snap.osc_snapshots[osc_name]
        prev_osc_snap = prev_snap.osc_snapshots[osc_name]

        write_RPC_gnrn_rate = get_write_RPC_gnrn_rate(cur_osc_snap, prev_osc_snap, record_dur)
        write_avg_xfer_speed = get_write_avg_xfer_speed(cur_osc_snap)
        avg_write_rpc_latency_per_unit_data = get_avg_write_rpc_latency_per_unit_data(cur_osc_snap)
        cur_osc_snap.save_write_params(write_RPC_gnrn_rate, write_avg_xfer_speed, avg_write_rpc_latency_per_unit_data)

        if is_distribution_centered(cur_osc_snap) == True:
            cur_osc_snap.is_dist_centered = 1
        else:
            cur_osc_snap.is_dist_centered = 0

        cur_osc_snap.waittime_to_mrif_ratio = int(int(cur_osc_snap.osc_req_waittime_data.get_average()) / cur_osc_snap.osc_rpc_configuration_current.mrif_value)
        cur_osc_snap.llite_write_bytes = llite_snap.llite_stats_write_bytes.samples_sum

def clear_all_osc_rpc_stats_data(cl_snap):
    for osc_name in cl_snap.osc_names:
        subprocess.call('echo "" > ' + osc_proc_path + osc_name + '/rpc_stats', shell=True)
        subprocess.call('echo "" > ' + osc_sys_kernel_path + osc_name + '/stats', shell=True)

def clear_llite_io_stats_data(cl_snap):
    subprocess.call('echo "" > ' + llite_sys_kernel_path + cl_snap.llite_snapshot.llite_fs_name + '/stats', shell=True)

def clear_system_stats_data(cl_snap):
    clear_all_osc_rpc_stats_data(cl_snap)
    clear_llite_io_stats_data(cl_snap)

from pickle import TRUE
def apply_random_config(cur_snap):   
    for osc_name in cur_snap.osc_names:  
        cur_osc_snap = cur_snap.osc_snapshots[osc_name]
        if cur_osc_snap.ost_read_rpc_bytes_data.no_of_samples == 0 and cur_osc_snap.ost_write_rpc_bytes_data.no_of_samples == 0:
            continue
        
        mppr_pow = random.randint(0,10)
        mrif_pow = random.randint(0,8)

        set_mppr_value(cur_osc_snap, pow(2, mppr_pow))
        set_mrif_value(cur_osc_snap, pow(2, mrif_pow))

def apply_first_random_config(cur_snap):
    for osc_name in cur_snap.osc_names:
        cur_osc_snap = cur_snap.osc_snapshots[osc_name]
        mppr_pow = random.randint(0,10)
        mrif_pow = random.randint(0,8)

        set_mppr_value(cur_osc_snap, pow(2, mppr_pow))
        set_mrif_value(cur_osc_snap, pow(2, mrif_pow))

def apply_mppr_action(cur_osc_snap, action):
    if action == "double":
        do_increase_mppr(cur_osc_snap, True)
    elif action == "half":
        do_increase_mppr(cur_osc_snap, False)
    else:
        return

def apply_mrif_action(cur_osc_snap, action):
    if action == "double":
        do_increase_mrif(cur_osc_snap, True)
    elif action == "half":
        do_increase_mrif(cur_osc_snap, False)
    else:
        return

def apply_one_of_three_actions(cur_snap):
    for osc_name in cur_snap.osc_names:
        cur_osc_snap = cur_snap.osc_snapshots[osc_name]
        rnd_action_pick = random.randint(1,3)
        
        if rnd_action_pick == 1:
            apply_mppr_action(cur_osc_snap, "double")
            apply_mrif_action(cur_osc_snap, "double")
        elif rnd_action_pick == 2:
            apply_mppr_action(cur_osc_snap, "half")
            apply_mrif_action(cur_osc_snap, "half")
        else:
            apply_mppr_action(cur_osc_snap, "unchanged")
            apply_mrif_action(cur_osc_snap, "unchanged")

def apply_independent_three_actions(cur_snap):
    for osc_name in cur_snap.osc_names:
        cur_osc_snap = cur_snap.osc_snapshots[osc_name]
        if cur_osc_snap.ost_read_rpc_bytes_data.no_of_samples == 0 and cur_osc_snap.ost_write_rpc_bytes_data.no_of_samples == 0:
            continue
        
        rnd_action_pick = random.randint(1,3)
        
        if rnd_action_pick == 1:
            apply_mppr_action(cur_osc_snap, "double")
        elif rnd_action_pick == 2:
            apply_mppr_action(cur_osc_snap, "half")
        else:
            apply_mppr_action(cur_osc_snap, "unchanged")

        rnd_action_pick = random.randint(1,3)
        
        if rnd_action_pick == 1:
            apply_mrif_action(cur_osc_snap, "double")
        elif rnd_action_pick == 2:
            apply_mrif_action(cur_osc_snap, "half")
        else:
            apply_mrif_action(cur_osc_snap, "unchanged")

def tune_params(result_folder_path, wld_name, cur_snap, prev_snap, record_dur):
    print('record_dur: ', record_dur)
    
    # Before this function call, populate_snapshot() has already been called.
    # We need to derive and save the features before moving ahead with tuning.
    save_features(cur_snap, prev_snap, record_dur)

    if is_dflt == 0:
        #apply_independent_three_actions(cur_snap)
        #apply_one_of_three_actions(cur_snap)
        apply_random_config(cur_snap)
        #tune_osc_params(cur_snap, prev_snap, record_dur)

    # must be called after all tuning decision has applied
    cur_snap.store_params_to_csv(result_folder_path, wld_name, record_dur)

if __name__ == "__main__":
    # relative path from the script
    result_folder_path = sys.argv[1]
    wld_name = sys.argv[2]
    is_dflt = int(sys.argv[3])
    if is_dflt == 1:
        is_dflt_txt = "dflt"

    prev_snap = Client_Snapshot()
    cur_snap = Client_Snapshot()

    clear_system_stats_data(cur_snap)
    begin_time = time.time()

    cur_snap.populate_snapshot()
    cur_snap.store_params_to_csv(result_folder_path, wld_name, round((time.time() - begin_time), 4))
    prev_snap = copy.deepcopy(cur_snap)

    while True:
        if int((time.time() - begin_time) * 1000) < 500:
            time.sleep(snap_record_duration - (time.time() - begin_time))

        end_time = time.time()
        cur_snap.populate_snapshot()
        record_dur = round((time.time() - begin_time), 4)
        prev_snap = copy.deepcopy(cur_snap)
        print('Snapshot Generation Time: ', int((time.time() - end_time) * 1000), ' miliseconds')

        clear_system_stats_data(cur_snap)
        begin_time = time.time()
        tune_params(result_folder_path, wld_name, cur_snap, prev_snap, record_dur)
        print('Processing Time (Before Sleeping): ', int((time.time() - begin_time) * 1000), ' miliseconds')